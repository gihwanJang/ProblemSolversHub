# 풀이

Union-find , greedy 알고리즘을 사용하는 문제

Union : 두 요소의 집합을 합치는 문제, 합칠 때 각 요소의 root값을 find 함수로 통해 찾아내서 변환해 줌.<br>
find : 주어진 매개변수의 root값을 찾아주는 함수. 
재귀함수 형태로 root로 거슬러 올라가고 root를 찾을 시 root값을 반환하여 모든 줄기들을 root값으로 변경해준다.

1. G(게이트 수), P(비행기 수), Gi(비행기 도킹 게이트 리스트) 값을 sys.stdin.readline으로 값을 받는다.
2. solution함수를 선언하고, 함수 내에서 table을 G+1의 크기로 union-find 알고리즘에 따라 인덱스 값을 value를 가지도록 1차원 리스트로 만들어준다.
3. 그 다음 P의 수 만큼 반복문을 돌리는데, 이때 union함수를 통해 table을 갱신해준다.
4. 이때의 반복문은 Gi[i](i+1번째 비행기의 도킹 가능 게이트) 집합의 root값이 0이 될 경우 i번째 비행기가 들어갈 게이트가 없다는 뜻이므로 i값을 리턴해주고
    반복문이 끝날때 까지 리턴이 안됐다면 모든 비행기가 gate에 들어간 것이므로 P의 값을 리턴해준다.
5. 반복문 동안 union함수를 이용하여 비행기가 게이트에 도킹되어있는지를 갱신해준다.
    union의 인자는 Gi[i], find(Gi[i], table)-1(Gi[i]의 집합의 root값-1 게이트), table 인 3개의 매개변수를 갖는다.
    이때 find의 인자는 Gi, table인데, table을 확인하여 Gi가 속한 집합의 root값을 찾아준다.

6. union함수의 매개변수로 받은 변수 P1, P2는 결국 gate번호인데 P2는 P1집합의 root값보다 하나 작은 수 이다.
7. 두 P1과 P2의 root를 find함수를 통해 찾아내고 두 root가 같을 경우는 같은 집합에 속해있는 것이므로 return해주고 다를 경우 P2의 root를 P1에 갱신시켜준다.
- P1의 루트를 갱신시켜주는 이유는 P2가 P1의 root보다 작은 값이므로 p2의 root를 p1에 갱신시켜주는 것.


### 고찰
1. python은 다른 언어에 비해 속도가 느리므로 sys를 사용한 방식으로 값을 입출력해야한다는 것을 알게됨.
2. 코드 밑에 주석으로 달아놓은 코드는 코드를 고치기 전에 사용했던 방식인데, union 부분에서 인자를 Gi[i]만 받아 union안에서 P1_root와 P2_root를 계산하였더니 시간초과가 발생함.
3. 주석 코드보다 이전에는 P1_root의 값을 P2_root의 값으로 갱신한 것이 아니라, P2의 값으로 갱신 시켰었는데 이 방식은 root의 값으로 갱신시킨 것이 아닌 꼬리잡기 형태로 갱신이 되기 때문에 시간복잡도가 늘어난다는 것을 깨달음.

