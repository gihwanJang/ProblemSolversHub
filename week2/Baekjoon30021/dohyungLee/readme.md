# 풀이

### 생각의 흐름
해당 문제를 풀기 위해 저의 생각의 흐름은 다음과 같이 진행되었습니다.

1. main 함수에서 N을 입력받는다.
2. present 함수에서 N을 1~N 순서대로 배열을 생성하고 stack을 이용하여 선물을 정한다.
3. stack에 쌓인 수를 소수인지 확인하기 위해 find_prime 함수를 만든다.

### Stack을 통한 선물 구성
선물을 보내기 위한 조건은 지금까지 나온 숫자들의 합이 소수가 아니어야 된다는 것입니다.<br>
때문에 일단 소수인지 확인하는 함수 find_prime을 정의하였습니다.<br>

또한 소수인지 체크하기 위해 숫자들을 보관할 '매개체'가 필요했습니다.<br>
'매개체'의 조건은 다음과 같습니다.
1. 이미 확인된 숫자는 '매개체'에 계속 보관되어야한다.
2. 합이 소수라면 '매개체'에 마지막으로 저장된 수를 쉽게 빼낼 수 있어야한다.<br>

위 조건을 충족하는 '매개체'로 저는 Stack이 활용될 수 있다고 생각했습니다.<br>
때문에 저는 present 함수를 다음과 같이 구성하였습니다.
1. 1~N 까지 숫자를 저장할 배열을 생성한다. (num_list)
2. Stack의 용도로 활용될 배열을 생성한다. (result_list)
3. Stack의 크기가 N이 될 때까지 Stack 채우기를 무한 반복한다.
4. Stack에 숫자를 순서대로 채운 후 소수 여부를 체크한다.
5. YES, NO를 출력한다. 이 때 1은 YES, 2는 NO로 정해놓는다.

---

# 느낀점 및 수정해야될 사항

- 3 이상일 때 NO가 되는 경우가 없었지만 이는 우연이므로 이에 대한 고려가 필요합니다.
- 처음 들어간 복소수에 다른 수를 더했을 때 복소수가 나오지 않는 것에 대한 고려가 필요합니다.
- 수학적으로 더욱 빠르게 풀 수 있는 방법이 있으므로 다른 해결책도 살펴봐야합니다.