# 풀이

- 크루스칼 알고리즘, 오프라인 쿼리

1. N Q,를 입력받고 N개의 체크포인트 정점 - NList, Q개의 질의 QList를 입력받는다
    - NList의 정점에 몇번째 정점인지 표기함.
    - QList 또한 오프라인 쿼리를 위해 몇번째 질의 인지 표기함.
2. QList를 hp 순서로 정렬시킴
    - 크루스칼 알고리즘의 union find를 사용할 때 집합 분리시키기는 어려우므로 hp순으로 정렬시켜 집합을 합치는 일만 진행.
3. 유니온 파인드를 사용하기 위한 node 리스트를 만듦.
4. 크루스칼 알고리즘을 사용하기 위해 간선을 만드는 make_edge 함수를 선언.
    - 간선은 각 정점마다 x축으로 가장 가까운 다른 정점과 y축으로 가장 가까운 다른 정점을 하나씩 만들어서 총 2n-2개의 간선을 만듦.
        - NList를 x에 대해 정렬한 x_sort
        - NList를 y에 대해 정렬한 y_sort
    - x_sort와 y_sort 리스트를 사용하여 간선을 만드는데
        - x = [[(i의 정점), (i+1의 정점), (i와 i+1 사이의 거리)], ...] 통해 간선을 만듦. 
        - y도 동일한 방식으로 만듦.
    - x에 대해 간선 n-1개, y에 대해 간선 n-1개를 합침
        - 2n-2개의 간선을 비용 순으로 정렬시키고 그 값을 리턴
5. make_edge로 만든 간선 edge와 정점 node를 이용하여 크루스칼 알고리즘 진행
    - kruskal(node, edge, hp, start)를 받음
    - 초기화하기 위해 (node, edge, 0, 0)을 전달하여 비용이 0인 부분을 반복문을 통해 비용이 0보다 작은 부분까지 node를 갱신시킴
    - 만약 비용보다 큰 값이 나오면 node[0]을 hp로 갱신시키고 어디까지 간선 리스트를 어디까지 진행시켰는지 i를 리턴시킴.
6. QList를 통해 start, end, hp, idx 값을 받아옴.
    - 만약 node[0] == hp 일 경우 ansList[idx]에 같은 집합안에 있는 건지 확인하고 같은 집합이면 'YES'를 아니면 'NO'를 갱신.
    - node[0]이 질의에서 받아온 hp보다 작을 경우 kruskal()함수를 통해
    hp까지의 간선을 다시 이어주기 시작함.

7. 이렇게 만들어낸 ansList를 출력하면됨.
