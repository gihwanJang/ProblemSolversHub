# 풀이

### 생각의 흐름
먼저, 입력 값에서 숫자와 연산 기호를 구분하였습니다.<br>
처음에는 모든 연산 기호를 같은 배열에 받았습니다.<br>
하지만, 없는 연산 기호 때문에 시간을 오래걸리게 하기 싫어 따로 저장했습니다.<br>
이 후 연산 기호 개수에 따라 다른 조건식을 세웠습니다.<br>
매우 비효율적이었지만 조건식은 아래와 같이 세웠습니다.<br>

### 비효율적인 조건식
1. +가 사용되지 않은 경우
- -도 사용되지 않은 경우 -> 곱셈만 진행
- *도 사용되지 않은 경우 -> 뺄셈만 진행
- +만 사용되지 않은 경우 -> 곱빼, 빼곱 두 가지 중 더 큰 수<br>

2. -가 사용되지 않은 경우
- +도 사용되지 않은 경우 -> 곱셈만 진행
- *도 사용되지 않은 경우 -> 덧셈만 진행
- -만 사용되지 않은 경우 -> 곱덧, 덧곰 두 가지 중 더 큰 수 <br>

3. *가 사용되지 않은 경우
- +도 사용되지 않은 경우 -> 뺄셈만 진행
- -도 사용되지 않은 경우 -> 덧셈만 진행
- *만 사용되지 않은 경우 -> 곱뺄, 뺄곰 두 가지 중 더 큰 수<br>

4. 모두 사용된 경우
- 6가지 경우의 수 모두 시행 그 중 가장 큰 수 반환

---

### 느낀점
난 왜 eval이라는 것을 몰랐던가...<br>
+ 진짜 미친 식이다 (사칙연산을 기준으로 split 후 eval 사용)<br>
```python
def solution(expression):
    operations = [('+', '-', '*'),('+', '*', '-'),('-', '+', '*'),('-', '*', '+'),('*', '+', '-'),('*', '-', '+')]
    answer = []
    for op in operations:
        a = op[0]
        b = op[1]
        temp_list = []
        for e in expression.split(a):
            temp = [f"({i})" for i in e.split(b)]
            temp_list.append(f'({b.join(temp)})')
        answer.append(abs(eval(a.join(temp_list))))
    return max(answer)
```